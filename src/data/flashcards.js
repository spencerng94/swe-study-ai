export const flashcards = [
  {
    id: 1,
    categoryId: 'ldv',
    category: 'Large Data Volumes (LDV)',
    question: 'What is Large Data Volumes (LDV) in Salesforce and what are the best practices?',
    answer: 'LDV refers to orgs with 50K+ records per object or 1M+ total records. Best practices: Use indexed fields in WHERE clauses, avoid SOQL in loops, use pagination, leverage SOSL for text searches, use selective filters (indexed fields), and consider data archiving strategies.',
  },
  {
    id: 2,
    categoryId: 'data-skew',
    category: 'Data Skew',
    question: 'What is Data Skew and how does it impact Salesforce performance?',
    answer: 'Data Skew occurs when a small number of parent records have a disproportionate number of child records. This causes: 1) Sharing calculation bottlenecks, 2) Lock contention during DML operations, 3) Query timeouts. Solutions: Redistribute data, use sharing rules instead of manual sharing, and avoid owner-based sharing for skewed data.',
  },
  {
    id: 3,
    categoryId: 'css-grid',
    category: 'CSS Grid for Calendars',
    question: 'How would you use CSS Grid to build a calendar layout?',
    answer: 'Use `display: grid` with `grid-template-columns: repeat(7, 1fr)` for 7 days. Use `grid-column` to span multi-day events. Use `grid-row` for time slots. Key properties: `grid-auto-rows: minmax(60px, auto)` for flexible row heights, `gap` for spacing, and `grid-template-areas` for named layout regions.',
  },
  {
    id: 4,
    categoryId: 'web-vitals',
    category: 'INP (Interaction to Next Paint)',
    question: 'What is INP and how do you optimize it?',
    answer: 'INP measures responsiveness - time from user interaction to next paint. Target: <200ms. Optimize by: 1) Debouncing/throttling event handlers, 2) Using passive event listeners, 3) Breaking up long tasks with setTimeout/scheduler.postTask, 4) Using requestIdleCallback for non-critical work, 5) Minimizing JavaScript execution time, 6) Using Web Workers for heavy computations.',
  },
  {
    id: 5,
    categoryId: 'ldv',
    category: 'Large Data Volumes (LDV)',
    question: 'What are the governor limits to be aware of in LDV scenarios?',
    answer: 'SOQL: 100 queries per transaction, 50K rows per query. DML: 150 statements, 10K records per DML. Heap: 6MB synchronous, 12MB asynchronous. CPU: 10s synchronous, 60s asynchronous. Use batch classes for large operations, leverage @future/queueable for async processing, and use Database.queryLocator for large result sets.',
  },
  {
    id: 6,
    categoryId: 'data-skew',
    category: 'Data Skew',
    question: 'What is the "Account Data Skew" problem specifically?',
    answer: 'When a single Account has 10K+ Contacts/Opportunities, it causes: 1) Sharing recalculation on every child record change, 2) Lock contention when multiple users work on children simultaneously, 3) Query timeouts when querying the Account. Solution: Create "bucket" Accounts to distribute child records, or use a custom junction object pattern.',
  },
  {
    id: 7,
    categoryId: 'css-grid',
    category: 'CSS Grid for Calendars',
    question: 'How do you handle overlapping events in a CSS Grid calendar?',
    answer: 'Use `grid-column` with calculated spans: `grid-column: start / end`. For overlaps, use `z-index` and absolute positioning within grid cells, or use a separate overlay layer. Consider using `grid-auto-flow: dense` to fill gaps. For complex overlaps, use JavaScript to calculate column assignments dynamically.',
  },
  {
    id: 8,
    categoryId: 'web-vitals',
    category: 'INP (Interaction to Next Paint)',
    question: 'What is the difference between FID and INP?',
    answer: 'FID (First Input Delay) measures only the FIRST user interaction delay. INP measures ALL interactions and uses the worst interaction. INP is more comprehensive for real-world UX. Both are Core Web Vitals, but INP replaced FID in 2024 as the responsiveness metric.',
  },
  {
    id: 9,
    categoryId: 'ldv',
    category: 'Large Data Volumes (LDV)',
    question: 'How do you optimize SOQL queries for LDV?',
    answer: '1) Use indexed fields (standard fields, custom fields with external IDs, formula fields with functions), 2) Use selective WHERE clauses (indexed fields, avoid functions on indexed fields), 3) Use LIMIT clause, 4) Select only needed fields, 5) Use FOR UPDATE only when necessary, 6) Avoid ORDER BY on non-indexed fields, 7) Use date range filters.',
  },
  {
    id: 10,
    categoryId: 'data-skew',
    category: 'Data Skew',
    question: 'What is "Sharing Skew" and how is it different from Data Skew?',
    answer: 'Sharing Skew: When a user has access to a small number of parent records that have millions of child records. This causes sharing calculation to process all children even though the user only needs a few. Solution: Use sharing rules, public groups, or custom sharing logic that doesn\'t cascade through skewed relationships.',
  },
  // JavaScript/Frontend Trivia Flashcards
  {
    id: 11,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is a closure in JavaScript?',
    answer: 'A closure is a function that has access to variables in its outer (enclosing) lexical scope, even after the outer function has returned. Closures are created every time a function is created. They allow data privacy and function factories. Example: `function outer() { let x = 1; return function inner() { return x++; }; }`',
  },
  {
    id: 12,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'Explain the JavaScript Event Loop and how it handles asynchronous code.',
    answer: 'The Event Loop continuously checks the call stack and task queues. When the call stack is empty, it moves tasks from queues to the stack. Order: 1) Execute synchronous code, 2) Process microtasks (Promises, queueMicrotask), 3) Process macrotasks (setTimeout, setInterval, I/O). Microtasks have higher priority and run before macrotasks.',
  },
  {
    id: 13,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between var, let, and const?',
    answer: '`var`: Function-scoped, hoisted (initialized as undefined), can be redeclared. `let`: Block-scoped, hoisted but in TDZ (Temporal Dead Zone), cannot be redeclared in same scope, can be reassigned. `const`: Block-scoped, hoisted but in TDZ, cannot be redeclared or reassigned (but object properties can be modified).',
  },
  {
    id: 14,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is hoisting in JavaScript?',
    answer: 'Hoisting is JavaScript\'s behavior of moving declarations to the top of their scope. `var` declarations are hoisted and initialized as `undefined`. `let` and `const` are hoisted but remain in the Temporal Dead Zone until the declaration line. Function declarations are fully hoisted (can be called before declaration).',
  },
  {
    id: 15,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'How does `this` binding work in JavaScript?',
    answer: '`this` is determined by how a function is called: 1) Regular functions: `this` = global object (strict: undefined) or caller object, 2) Arrow functions: `this` = lexical `this` from enclosing scope, 3) Methods: `this` = object calling the method, 4) `call/apply/bind`: explicitly set `this`, 5) `new`: `this` = new instance.',
  },
  {
    id: 16,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between == and ===?',
    answer: '`==` (loose equality) performs type coercion before comparison. `===` (strict equality) checks both value and type without coercion. Examples: `5 == "5"` is true, `5 === "5"` is false. `null == undefined` is true, `null === undefined` is false. Always prefer `===` for predictable behavior.',
  },
  {
    id: 17,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'Explain Promise.all, Promise.allSettled, and Promise.race.',
    answer: '`Promise.all`: Resolves when all promises resolve, rejects if any reject. `Promise.allSettled`: Waits for all promises to settle (resolve or reject), returns array of results. `Promise.race`: Resolves/rejects with the first promise that settles. Use `all` for dependent operations, `allSettled` when you need all results, `race` for timeouts/competition.',
  },
  {
    id: 18,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between async/await and Promises?',
    answer: 'Both handle asynchronous operations. `async/await` is syntactic sugar over Promises, making async code look synchronous. `async` functions return Promises. `await` pauses execution until the Promise resolves. Benefits: cleaner code, easier error handling with try/catch, better stack traces. Under the hood, it\'s still Promises.',
  },
  {
    id: 19,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is a pure function?',
    answer: 'A pure function: 1) Always returns the same output for the same input, 2) Has no side effects (doesn\'t modify external state), 3) Doesn\'t depend on mutable external state. Benefits: predictable, testable, cacheable, easier to reason about. Example: `const add = (a, b) => a + b`',
  },
  {
    id: 20,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'Explain the prototype chain in JavaScript.',
    answer: 'Every object has a prototype. When accessing a property, JavaScript looks up the chain: object → prototype → prototype.prototype → ... → Object.prototype → null. Functions have a `prototype` property used when called with `new`. `__proto__` (or `Object.getPrototypeOf()`) accesses the prototype. Classes use prototypes under the hood.',
  },
  {
    id: 21,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is debouncing and throttling?',
    answer: 'Debouncing: Execute function after a delay when events stop firing (e.g., search input). Throttling: Execute function at most once per time period (e.g., scroll handler). Debounce waits for pause, throttle limits execution frequency. Use debounce for expensive operations on user input, throttle for scroll/resize handlers.',
  },
  {
    id: 22,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What are arrow functions and when should you use them?',
    answer: 'Arrow functions: `(param) => expression` or `(param) => { statements }`. Differences: No `this` binding (uses lexical `this`), no `arguments` object, cannot be used as constructors, no `prototype`. Use for: callbacks, methods that need lexical `this`, concise syntax. Avoid for: object methods needing `this`, constructors, functions needing `arguments`.',
  },
  {
    id: 23,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the Temporal Dead Zone (TDZ)?',
    answer: 'TDZ is the period between entering scope and the declaration line where `let` and `const` variables cannot be accessed. Variables are hoisted but not initialized. Accessing them throws `ReferenceError`. `var` is initialized as `undefined` (no TDZ). Example: `console.log(x); let x = 5;` throws error.',
  },
  {
    id: 24,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'Explain destructuring in JavaScript.',
    answer: 'Destructuring extracts values from arrays/objects into variables. Array: `const [a, b] = [1, 2]`. Object: `const {name, age} = person`. Can use defaults: `const {name = "Unknown"} = person`. Rename: `const {name: fullName} = person`. Rest: `const [first, ...rest] = arr`. Nested: `const {user: {name}} = data`.',
  },
  {
    id: 25,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the spread operator and how is it used?',
    answer: 'Spread (`...`) expands iterables into individual elements. Arrays: `[...arr1, ...arr2]` (merge), `[...arr]` (copy). Objects: `{...obj1, ...obj2}` (merge), `{...obj, newProp: value}` (update). Function args: `fn(...args)`. Use for: copying arrays/objects, merging, passing array as arguments, creating new objects with updates.',
  },
  {
    id: 26,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between null and undefined?',
    answer: '`undefined`: Variable declared but not assigned, missing property, function with no return. `null`: Explicitly assigned "no value", intentional absence. Type: `typeof undefined` is "undefined", `typeof null` is "object" (historical bug). `null == undefined` is true, `null === undefined` is false. Use `null` for intentional absence, `undefined` for uninitialized.',
  },
  {
    id: 27,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'Explain the difference between map, filter, and reduce.',
    answer: '`map`: Transforms each element, returns new array of same length. `filter`: Returns new array with elements passing test. `reduce`: Accumulates array into single value (or object/array). `map` for transformations, `filter` for selection, `reduce` for aggregation. All are pure functions (don\'t mutate original).',
  },
  {
    id: 28,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is a higher-order function?',
    answer: 'A function that takes one or more functions as arguments or returns a function. Examples: `map`, `filter`, `reduce`, `setTimeout`, `addEventListener`. Benefits: abstraction, reusability, composition. Example: `const multiplyBy = (n) => (x) => x * n; const double = multiplyBy(2);`',
  },
  {
    id: 29,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is currying?',
    answer: 'Currying transforms a function with multiple arguments into a sequence of functions, each taking one argument. `const add = (a) => (b) => a + b; const add5 = add(5); add5(3)` returns 8. Benefits: partial application, function composition, cleaner code. Related to higher-order functions.',
  },
  {
    id: 30,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is memoization and how do you implement it?',
    answer: 'Memoization caches function results for given inputs. Implement with closure: `const memoize = (fn) => { const cache = {}; return (...args) => { const key = JSON.stringify(args); return cache[key] || (cache[key] = fn(...args)); }; };`. Use for expensive computations, recursive functions (Fibonacci), API calls with same params.',
  },
  {
    id: 31,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'Explain the difference between shallow copy and deep copy.',
    answer: 'Shallow copy: Copies top-level properties, nested objects/arrays are references. Methods: `{...obj}`, `Object.assign({}, obj)`, `[...arr]`. Deep copy: Creates new objects for all nested structures. Methods: `JSON.parse(JSON.stringify(obj))` (limitations: no functions/dates), `structuredClone()` (modern), libraries like Lodash. Use deep copy when nested mutations matter.',
  },
  {
    id: 32,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the event delegation pattern?',
    answer: 'Event delegation attaches a single event listener to a parent element instead of multiple listeners on children. Uses event bubbling. Benefits: better performance, works with dynamically added elements, less memory. Example: `parent.addEventListener("click", (e) => { if (e.target.matches(".button")) { ... } })`.',
  },
  {
    id: 33,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between call, apply, and bind?',
    answer: 'All set `this` context. `call`: Invokes function with `this` and individual arguments. `apply`: Invokes with `this` and array of arguments. `bind`: Returns new function with bound `this` and optionally pre-filled arguments (partial application). `call`/`apply` execute immediately, `bind` returns a function.',
  },
  {
    id: 34,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What are generators and how do they work?',
    answer: 'Generators are functions that can pause and resume execution using `yield`. Syntax: `function* gen() { yield 1; yield 2; }`. Call `next()` to resume, returns `{value, done}`. Use for: lazy evaluation, infinite sequences, async iteration, coroutines. Example: `const gen = gen(); gen.next()` returns `{value: 1, done: false}`.',
  },
  {
    id: 35,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between for...in and for...of loops?',
    answer: '`for...in`: Iterates over enumerable property keys (including inherited), works with objects. `for...of`: Iterates over iterable values (arrays, strings, Maps, Sets), works with iterables. Use `for...in` for object keys, `for...of` for array/iterable values. `for...in` can include prototype properties, use `hasOwnProperty` to filter.',
  },
  {
    id: 36,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between Object.freeze, Object.seal, and Object.preventExtensions?',
    answer: '`Object.preventExtensions`: Prevents adding new properties. `Object.seal`: Prevents adding/removing properties, but existing properties can be modified. `Object.freeze`: Prevents all modifications (add, delete, modify). All are shallow. Use for immutability, preventing accidental changes. `Object.isFrozen()`, `Object.isSealed()` check status.',
  },
  {
    id: 37,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'Explain the module system: CommonJS vs ES6 modules.',
    answer: 'CommonJS (Node.js): `module.exports = {}`, `require()`, synchronous loading, runtime resolution. ES6 modules: `export`/`import`, static analysis, tree-shaking, top-level await. ES6 modules are hoisted, have strict mode by default, support named/default exports. Use ES6 modules in modern JS, CommonJS in Node.js legacy code.',
  },
  {
    id: 38,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between setTimeout and setInterval?',
    answer: '`setTimeout`: Executes function once after delay. `setInterval`: Executes function repeatedly at intervals. Both return timer ID for `clearTimeout`/`clearInterval`. `setTimeout` is more reliable for intervals (avoids overlap, can adjust timing). Use `setTimeout` recursively for precise intervals: `const run = () => { fn(); setTimeout(run, delay); }`.',
  },
  {
    id: 39,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between function declaration and function expression?',
    answer: 'Declaration: `function fn() {}` - hoisted (can call before declaration), has function name. Expression: `const fn = function() {}` - not hoisted, can be anonymous or named. Arrow functions are expressions. IIFE: `(function() {})()` - immediately invoked. Use declarations for hoisting, expressions for conditional creation, callbacks.',
  },
  {
    id: 40,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between slice and splice?',
    answer: '`slice(start, end)`: Returns new array with selected elements, doesn\'t modify original. `splice(start, deleteCount, ...items)`: Modifies array, removes/inserts elements, returns removed elements. `slice` is pure (no mutation), `splice` mutates. Use `slice` for copying/extracting, `splice` for in-place modification.',
  },
  {
    id: 41,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What are WeakMap and WeakSet?',
    answer: 'WeakMap/WeakSet hold weak references (don\'t prevent garbage collection). WeakMap: keys must be objects, no iteration, no size property. WeakSet: values must be objects, no iteration. Use for: private data, metadata, caches that should be GC\'d. Regular Map/Set hold strong references and prevent GC.',
  },
  {
    id: 42,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between Array.from and Array.of?',
    answer: '`Array.from(arrayLike, mapFn)`: Creates array from array-like/iterable (NodeList, arguments, string). `Array.of(...elements)`: Creates array from arguments. `Array.from("abc")` → `["a","b","c"]`. `Array.of(1,2,3)` → `[1,2,3]`. `Array.from` is more versatile, `Array.of` is explicit array creation from values.',
  },
  {
    id: 43,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'Explain React\'s virtual DOM and how it works.',
    answer: 'Virtual DOM is a JavaScript representation of the real DOM. React creates a virtual tree, compares with previous (diffing), and updates only changed nodes (reconciliation). Benefits: performance (batched updates), declarative API, cross-platform (React Native). React Fiber (v16+) enables incremental rendering and priority-based updates.',
  },
  {
    id: 44,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between React state and props?',
    answer: 'Props: Data passed from parent to child, immutable, read-only. State: Internal component data, mutable with `setState`/`useState`, triggers re-render when changed. Props flow down, state is local. Use props for configuration, state for interactive data. Lift state up when multiple components need same data.',
  },
  {
    id: 45,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'Explain React hooks: useState, useEffect, useMemo, useCallback.',
    answer: '`useState`: Manages component state, returns `[value, setter]`. `useEffect`: Side effects (API calls, subscriptions), runs after render, dependency array controls when. `useMemo`: Memoizes computed values, prevents recalculation. `useCallback`: Memoizes functions, prevents recreation. Use for performance optimization, avoid unnecessary re-renders.',
  },
  {
    id: 46,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between controlled and uncontrolled components?',
    answer: 'Controlled: Form data handled by React state, `value` prop + `onChange`. Uncontrolled: Form data handled by DOM, `ref` to access values. Controlled: predictable, easier validation, single source of truth. Uncontrolled: less code, better for simple forms, integrates with non-React code. Prefer controlled for most cases.',
  },
  {
    id: 47,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'Explain React key prop and why it\'s important.',
    answer: '`key` helps React identify which items changed/added/removed in lists. Should be unique, stable, predictable. Use IDs from data, not array indices (causes issues with reordering). Without keys, React may incorrectly reuse components, causing state bugs. Keys are not passed as props to components.',
  },
  {
    id: 48,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is React.memo and when should you use it?',
    answer: '`React.memo` is a higher-order component that memoizes functional components. Prevents re-render if props haven\'t changed (shallow comparison). Use for expensive components, components that render frequently, when parent re-renders often. Don\'t overuse - adds comparison overhead. Use with `useMemo`/`useCallback` for props.',
  },
  {
    id: 49,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between useMemo and useCallback?',
    answer: '`useMemo`: Memoizes computed values, returns memoized value. `useCallback`: Memoizes functions, returns memoized function. Both take dependency array. Use `useMemo` for expensive calculations, `useCallback` for functions passed as props (prevent child re-renders). Both prevent unnecessary recalculations/recreations.',
  },
  {
    id: 50,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'Explain React Context API and when to use it.',
    answer: 'Context provides a way to pass data through component tree without prop drilling. Create with `createContext()`, provide with `<Context.Provider>`, consume with `useContext()`. Use for: theme, user auth, language, global state. Avoid for: frequently changing data (causes re-renders), small prop chains. Consider state management libraries for complex state.',
  },
  {
    id: 51,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between useRef and useState?',
    answer: '`useState`: Manages state, triggers re-render on change, returns `[value, setter]`. `useRef`: Mutable ref object, doesn\'t trigger re-render, persists across renders, `.current` property. Use `useState` for UI state, `useRef` for DOM references, previous values, timers, mutable values that don\'t need re-render.',
  },
  {
    id: 52,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is code splitting in React and how do you implement it?',
    answer: 'Code splitting splits bundle into smaller chunks, loaded on demand. Methods: `React.lazy()` + `Suspense` for component-level, dynamic `import()` for route-level. Benefits: faster initial load, reduced bundle size. Example: `const LazyComponent = React.lazy(() => import("./Component")); <Suspense fallback={<Spinner />}><LazyComponent /></Suspense>`.',
  },
  {
    id: 53,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'Explain React error boundaries and how they work.',
    answer: 'Error boundaries catch JavaScript errors in child components, log them, display fallback UI. Class component with `componentDidCatch` or `getDerivedStateFromError`. Only catches errors in render, lifecycle, constructors. Doesn\'t catch: event handlers, async code, SSR, boundary itself. Use to prevent entire app crashes.',
  },
  {
    id: 54,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between useLayoutEffect and useEffect?',
    answer: '`useEffect`: Runs after paint, asynchronous, doesn\'t block browser. `useLayoutEffect`: Runs synchronously after DOM mutations but before paint, blocks paint. Use `useLayoutEffect` for: DOM measurements, preventing visual flicker, synchronous DOM updates. Use `useEffect` for most cases (better performance).',
  },
  {
    id: 55,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between imperative and declarative programming?',
    answer: 'Imperative: How to do (step-by-step instructions). Declarative: What to do (describe desired outcome). React is declarative: describe UI state, React handles updates. Imperative: `element.style.color = "red"`. Declarative: `<div style={{color: "red"}}>`. Benefits: easier to reason about, less bugs, more maintainable.',
  },
  {
    id: 56,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the event loop execution order?',
    answer: '1) Execute all synchronous code, 2) Process all microtasks (Promise.then, queueMicrotask), 3) Process one macrotask (setTimeout, setInterval, I/O), 4) Repeat. Microtasks have priority: all microtasks run before next macrotask. Example: Promise resolves → microtask queue → setTimeout → macrotask queue.',
  },
  {
    id: 57,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between microtasks and macrotasks?',
    answer: 'Microtasks: Promise callbacks, queueMicrotask, process.nextTick (Node). Macrotasks: setTimeout, setInterval, I/O, UI rendering. Microtasks execute before macrotasks. All microtasks in queue run before next macrotask. Use microtasks for immediate async operations, macrotasks for delayed operations. Order matters for event loop behavior.',
  },
  {
    id: 58,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is a closure trap in loops and how do you fix it?',
    answer: 'Closure trap: Loop variable is shared across iterations, closures capture final value. Fix: Use `let` (block scope), IIFE with parameter, `forEach`/`map` (new scope per iteration), or `bind`. Example: `for (let i = 0; i < 3; i++) { setTimeout(() => console.log(i), 100); }` - `let` creates new binding per iteration.',
  },
  {
    id: 59,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between Object.create and new?',
    answer: '`Object.create(proto)`: Creates object with specified prototype, doesn\'t call constructor. `new Constructor()`: Creates object, calls constructor, sets prototype to Constructor.prototype. Use `Object.create` for: prototype chains without constructors, object composition. Use `new` for: class instances, constructor-based objects.',
  },
  {
    id: 60,
    categoryId: 'js-frontend',
    category: 'JavaScript Frontend',
    question: 'What is the difference between Array methods: forEach, map, filter, reduce, find, some, every?',
    answer: '`forEach`: Executes function, returns undefined. `map`: Returns new array. `filter`: Returns filtered array. `reduce`: Returns accumulated value. `find`: Returns first matching element. `some`: Returns boolean if any match. `every`: Returns boolean if all match. All iterate, but different purposes and return values.',
  },
]

export const flashcardCategories = [
  {
    id: 'ldv',
    label: 'Large Data Volumes (LDV)',
    summary: 'Selective queries, governor limits, indexing, and data archiving strategies.',
    skills: ['SOQL tuning', 'Indexes', 'Limits'],
    color: 'blue',
  },
  {
    id: 'data-skew',
    label: 'Data Skew',
    summary: 'Avoid lock contention and sharing recalculations in skewed ownership models.',
    skills: ['Locking', 'Sharing', 'Modeling'],
    color: 'amber',
  },
  {
    id: 'css-grid',
    label: 'CSS Grid for Calendars',
    summary: 'Responsive grids, overlapping events, and modern layout techniques.',
    skills: ['Layout', 'Grid', 'UI patterns'],
    color: 'emerald',
  },
  {
    id: 'web-vitals',
    label: 'INP (Interaction to Next Paint)',
    summary: 'Responsive UX and performance tuning for modern Core Web Vitals.',
    skills: ['Performance', 'Event handling', 'Web Vitals'],
    color: 'purple',
  },
  {
    id: 'js-frontend',
    label: 'JavaScript Frontend',
    summary: 'Closures, event loop, promises, React hooks, and modern JavaScript patterns.',
    skills: ['Closures', 'Event Loop', 'React', 'ES6+', 'Async'],
    color: 'indigo',
  },
]
